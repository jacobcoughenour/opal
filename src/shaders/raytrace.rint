#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#include "raycommon.glsl"
#include "wavefront.glsl"

// layout(binding = 7, set = 1, scalar) buffer allSpheres_ {
// 	Sphere allSpheres[];
// };

layout(binding = 7, set = 1, scalar) buffer allVolumes_ {
	Volume allVolumes[];
};
layout(binding = 8, set = 1) uniform sampler3D[] volumeDensityTextures;

struct Ray {
	vec3 origin;
	vec3 direction;
};

float hitAabb(const Aabb aabb, const Ray r) {
	vec3 invDir = 1.0 / r.direction;
	vec3 tbot = invDir * (aabb.minimum - r.origin);
	vec3 ttop = invDir * (aabb.maximum - r.origin);
	vec3 tmin = min(ttop, tbot);
	vec3 tmax = max(ttop, tbot);
	float t0 = max(tmin.x, max(tmin.y, tmin.z));
	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	return t1 > max(t0, 0.0) ? t0 : -1.0;
}

void main() {
	Ray ray;
	ray.origin = gl_WorldRayOriginEXT;
	ray.direction = gl_WorldRayDirectionEXT;

	Volume volume = allVolumes[gl_PrimitiveID];

	Aabb aabb;
	aabb.minimum = volume.position;
	aabb.maximum = volume.position + volume.size;
	// float tHit = hitAabb(aabb, ray);

	// if (tHit > 0) {

	vec3 rrd = 1.0 / ray.direction;
	vec3 bias = rrd * ray.origin;

	vec3 box_min = aabb.minimum;
	vec3 box_max = aabb.maximum;

	float t_min = max_elem(min(box_min, box_max));
	float t_max = min_elem(max(box_min, box_max));

	if (t_min > max(t_max, 0.0)) {
		// Ray misses bounding cube
		return;
	}

	t_min = max(t_min, 0);

	vec3 ro = ray.origin + ray.direction * t_min;
	ivec3 pos = ivec3(ro);

	vec3 t_delta = abs(rrd);
	vec3 sgn = sign(ray.direction);
	ivec3 step = ivec3(sgn);
	vec3 side_dist = (sgn * (floor(ro) - ro + 0.5) + 0.5) * t_delta;

	float t = 0;

	vec4 total = vec4(0);
	while (t < t_max - t_min && total.a < 1.0) {
		bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));

		float t0 = min_elem(side_dist);

		total += texture(volumeDensityTextures[volume.densityTextureId], pos).rgba;
		// total += texelFetch(model, pos, 0).rgb * (t0 - t);

		t = t0;

		side_dist += mix(vec3(0), t_delta, mask);
		pos += mix(ivec3(0), step, mask);
	}

	if (total.a > 0.0) {
		reportIntersectionEXT(total.a, KIND_CUBE);
	}
	// }
}